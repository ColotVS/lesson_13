public class lesson_13_16 {
    //Как устроен ArrayList

    //ArrayList — самый распространённый класс в Java для хранения элементов.
    //Так как же устроен этот ArrayList и почему он так всем нравится?
    //Устройство ArrayList простое и гениальное по своей сути. Внутри каждого объекта ArrayList есть два поля:
    //Массив со списком элементов
    //Переменная size, которая хранит количество элементов списка

    //Внутри объекта ArrayList содержится самый обычный массив! Но не только.

    //Там есть еще переменная size, которая хранит длину списка. Вот как это работает:
    //Изначально длина массива внутри списка — 10 элементов. А переменная size равна 0.
    //Если в список добавить элемент, он будет сохранен в 0-ю ячейку массива, а size увеличится до 1.
    //Если добавить еще один элемент, он будет сохранен в 1-ю ячейку, а size снова увеличится на 1 и теперь будет равняться двум.


    //Если при добавлении очередного элемента в список в массиве уже нет места, в методе add() происходит следующее:
    //создается новый массив в полтора раза длиннее предыдущего
    //в него копируются все элементы из существующего массива
    //в объекте ArrayList вместо старого массива сохраняется ссылка на новый.
    //В 10-ю ячейку нового массива записывается переданный элемент
    //size увеличивается на 1 и теперь будет равняться 11

    //Аналогично при добавлении (вставке) элемента в середину списка.
    //Существующие элементы сдвигаются на 1 вправо, и в свободную ячейку массива записывается нужный элемент.

    //ArrayList — это список, который хранит динамически расширяемый массив элементов. Сейчас мы будем реализовывать свою версию списка,
    //в котором хранятся строки.
    //В классе CustomStringArrayList есть три поля:
    //String[] elements — это массив текущих элементов (в похожем массиве хранит значения ArrayList).
    //Изначально его размер равен 10 (capacity = 10).
    //int size — в нем хранится количество заполненных элементов, начальное значение — 0.
    //int capacity — вместимость в текущем массиве (elements) данных, которая будет увеличиваться по ходу добавления данных.

    //Для простоты реализации у нас будут только два метода:
    //Публичный метод add(String), добавляющий элементы в массив, с помощью которого мы сможем увидеть, как массив динамически расширяется.
    //Когда массив заполнен (size == capacity), вызывается метод grow() для расширения массива.
    //Приватный метод grow(), который должен присвоить полю elements новый массив вместимостью (capacity) в полтора раза больше,
    //чем у старого массива и скопировать данные из старого массива в новый в том же порядке.
    //Поле capacity должно увеличиться точно так же, как и размер массива.
    public static void main(String[] args) {
        CustomStringArrayList arrayList = new CustomStringArrayList();
        for(int i = 0; i < 25; i++) {
            arrayList.add("count" + i);
        }
    }

}
class CustomStringArrayList {

    private int size;
    private int capacity;
    private String[] elements;

    public CustomStringArrayList() {
        capacity = 10;
        size = 0;
        elements = new String[capacity];
    }

    public void add(String element) {
        if (size == capacity) {
            grow();
        }
        elements[size] = element;
        size++;
    }

    private void grow() {
        capacity = (int) (capacity*1.5);
        String [] elem = new String[capacity];
        for (int i = 0; i < elements.length; i++) {
            elem[i]=elements[i];
        }
        elements = new String[capacity];
        for (int i = 0; i < elem.length; i++) {
            elements[i] = elem[i];
        }
    }
}
